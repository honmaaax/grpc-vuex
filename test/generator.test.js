import fs from 'fs'
import path from 'path'
import Promise from 'bluebird'
import _ from 'lodash'
import rmrf from 'rmrf'

import {
  toJSON,
  getServices,
  getMessages,
  getModels,
  getMutationTypes,
  getActions,
} from '../src/protobuf'
import {
  generateImportCode,
  generateMutationTypesCode,
  generateInitGrpcCode,
  generateRequestCode,
  generateActionsCode,
  generateFileByProtoc,
  generateFileByProtocDependencies,
  generateCode,
  generateDtsCode,
} from '../src/generator'

const proto = `
  syntax = "proto3";

  package helloworld;

  service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
  }

  message User {
    string name = 1;
    int32 age = 2;
    repeated string children = 3;
  }

  message HelloRequest {
    repeated User users = 1;
  }

  message HelloReply {
    repeated User users = 1;
  }
`

const proto2 = `
  syntax = "proto3";

  package assetter;

  option go_package = "assetter";

  service PingService {
    rpc SendPing (PingRequest) returns (PingResponse) {}
  }

  message PingRequest {}

  message PingResponse {
    string message = 1;
  }
`

describe('generateFileByProtoc', ()=>{
  beforeAll(()=>{
    const dirPath = '.grpc-vuex'
    return Promise.resolve()
      .then(()=>{
        if ( fs.existsSync(dirPath) ) {
          return rmrf(dirPath)
        }
      })
      .then(()=>Promise.promisify(fs.mkdir)(dirPath))
      .then(()=>Promise.all([
        generateFileByProtoc('./test/grpc/helloworld.proto'),
        generateFileByProtoc('./test/grpc/pbonly.proto'),
      ]))
  })
  it('returns code generated by Protoc', ()=>{
    expect(fs.existsSync('./.grpc-vuex/helloworld_grpc_web_pb.js')).toBeTruthy()
    expect(fs.existsSync('./.grpc-vuex/helloworld_pb.js')).toBeTruthy()
  })
  it('generates only pb file', ()=>{
    expect(fs.existsSync('./.grpc-vuex/pbonly_grpc_web_pb.js')).toBeFalsy()
    expect(fs.existsSync('./.grpc-vuex/pbonly_pb.js')).toBeTruthy()
  })
})

describe('generateFileByProtocDependencies', ()=>{
  const protoFiles = [
    {
      "dir": "/Users/b07781/go/src",
      "file": "github.com/mwitkow/go-proto-validators/validator.proto"
    },
    {
      "dir": "/Users/b07781/go/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis",
      "file": "google/api/annotations.proto",
      "dependencies": [
        {
          "dir": "/Users/b07781/go/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis",
          "file": "google/api/http.proto"
        },
      ],
    }
  ]
  beforeAll(()=>{
    return Promise.resolve()
      .then(()=>{
        const dirPath = '.grpc-vuex'
        if ( !fs.existsSync(dirPath) ) {
          return Promise.promisify(fs.mkdir)(dirPath)
        }
      })
      .then(()=>Promise.all([
        Promise.promisify(fs.stat)('./.grpc-vuex/github.com/mwitkow/go-proto-validators/validator_pb.js'),
        Promise.promisify(fs.stat)('./.grpc-vuex/google/api/annotations_pb.js'),
        Promise.promisify(fs.stat)('./.grpc-vuex/google/api/google/api/http_pb.js'),
      ]))
      .then(()=>{
        return Promise.all([
          Promise.promisify(fs.unlink)('./.grpc-vuex/github.com/mwitkow/go-proto-validators/validator_pb.js'),
          Promise.promisify(fs.unlink)('./.grpc-vuex/google/api/annotations_pb.js'),
          Promise.promisify(fs.stat)('./.grpc-vuex/google/api/google/api/http_pb.js'),
        ])
      }, ()=>{})
      .then(()=>generateFileByProtocDependencies(protoFiles))
  })
  it('returns code generated by Protoc', ()=>{
    return Promise
      .all([
        Promise.promisify(fs.stat)('./.grpc-vuex/github.com/mwitkow/go-proto-validators/validator_pb.js'),
        Promise.promisify(fs.stat)('./.grpc-vuex/google/api/annotations_pb.js'),
        Promise.promisify(fs.stat)('./.grpc-vuex/google/api/google/api/http_pb.js'),
      ])
      .then(()=>{
        expect(true).toBeTruthy()
      })
  })
})

describe('generateImportCode', ()=>{
  it('returns js code', () => {
    const messageProtos = ['helloworld']
    const clientProtos = [{
      protoName: 'helloworld',
      client: 'GreeterPromiseClient',
    }]
    const code = generateImportCode(messageProtos, clientProtos)
    expect(code).toBe(
`import GRPC from './grpc'
import { logRequest, logResponse, logError } from './debug'
import { createRequest } from './request'
import { convertResponse } from './response'
import helloworld from './helloworld_pb'
import { GreeterPromiseClient } from './helloworld_grpc_web_pb'`
    )
  })
})

describe('generateMutationTypesCode', ()=>{
  it('returns js code', () => {
    const json = toJSON(proto)
    const services = getServices(json)
    const mutationTypes = getMutationTypes(services)
    const code = generateMutationTypesCode(mutationTypes)
    expect(code).toBe(
`export const types = {
  GREETER_SAYHELLO: 'GREETER_SAYHELLO',
}`
    )
  })
})

describe('generateInitGrpcCode', ()=>{
  it('returns js code', () => {
    const endpoint = 'http://localhost:8080/'
    const code = generateInitGrpcCode(endpoint)
    expect(code).toBe(`export const grpc = new GRPC('${endpoint}')`)
  })
})

describe('generateRequestCode', ()=>{
  it('returns js code', () => {
    const code = generateRequestCode('helloworld', 'HelloRequest', {HelloRequest: {users: {type: 'User', namespace: 'helloworld'}}})
    expect(code).toBe(`const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})`)
  })
})

describe('generateActionsCode', ()=>{
  it('returns js code', () => {
    const json = toJSON(proto)
    const services = getServices(json)
    const messages = getMessages(json)
    const models = getModels(messages, 'helloworld')
    const actions = getActions(services, 'helloworld')
    const param = {
      actions,
      models,
    }
    const code = generateActionsCode([param, param])
    expect(code).toBe(
`export function sayHello (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})
  return grpc.call({
      client: GreeterPromiseClient,
      method: 'sayHello',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      if (arg.hasMutation) context.commit(types.GREETER_SAYHELLO, res)
      return res
    })
}
export function sayHello (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})
  return grpc.call({
      client: GreeterPromiseClient,
      method: 'sayHello',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      if (arg.hasMutation) context.commit(types.GREETER_SAYHELLO, res)
      return res
    })
}`
    )
  })
})

describe('generateCode', ()=>{
  const protoFilePath = './test/grpc/helloworld.proto'
  const protoName =  path.basename(protoFilePath, '.proto')
  beforeAll(()=>{
    return generateFileByProtoc(protoFilePath)
  })
  it('returns js code', () => {
    const json = toJSON(proto)
    const services = getServices(json)
    const messages = getMessages(json)
    const models = getModels(messages, protoName)
    const mutationTypes = getMutationTypes(services)
    const actions = getActions(services, protoName)
    const param = {
      mutationTypes,
      actions,
      models,
    }
    const code = generateCode([param, param], 'http://localhost:8080/')
    expect(_.isString(code)).toBeTruthy()
    expect(code).toBe(
`import GRPC from './grpc'
import { logRequest, logResponse, logError } from './debug'
import { createRequest } from './request'
import { convertResponse } from './response'
import helloworld from './helloworld_pb'
import { GreeterPromiseClient } from './helloworld_grpc_web_pb'

export const types = {
  GREETER_SAYHELLO: 'GREETER_SAYHELLO',
  GREETER_SAYHELLO: 'GREETER_SAYHELLO',
}

export const grpc = new GRPC('http://localhost:8080/')
export function sayHello (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})
  return grpc.call({
      client: GreeterPromiseClient,
      method: 'sayHello',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      if (arg.hasMutation) context.commit(types.GREETER_SAYHELLO, res)
      return res
    })
}
export function sayHello (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})
  return grpc.call({
      client: GreeterPromiseClient,
      method: 'sayHello',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      if (arg.hasMutation) context.commit(types.GREETER_SAYHELLO, res)
      return res
    })
}
`
    )
  })
  it('returns debug mode js code', () => {
    const json = toJSON(proto)
    const services = getServices(json)
    const messages = getMessages(json)
    const models = getModels(messages, protoName)
    const mutationTypes = getMutationTypes(services)
    const actions = getActions(services, protoName)
    const param = {
      mutationTypes,
      actions,
      models,
    }
    const code = generateCode([param, param], 'http://localhost:8080/', true)
    expect(_.isString(code)).toBeTruthy()
    expect(code).toBe(
`import GRPC from './grpc'
import { logRequest, logResponse, logError } from './debug'
import { createRequest } from './request'
import { convertResponse } from './response'
import helloworld from './helloworld_pb'
import { GreeterPromiseClient } from './helloworld_grpc_web_pb'

export const types = {
  GREETER_SAYHELLO: 'GREETER_SAYHELLO',
  GREETER_SAYHELLO: 'GREETER_SAYHELLO',
}

export const grpc = new GRPC('http://localhost:8080/')
export function sayHello (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})
  logRequest('sayHello', arg.params)
  return grpc.call({
      client: GreeterPromiseClient,
      method: 'sayHello',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      logResponse('sayHello', JSON.parse(JSON.stringify(res)))
      if (arg.hasMutation) context.commit(types.GREETER_SAYHELLO, res)
      return res
    })
    .catch((err)=>{
      logError('sayHello', err)
      throw err
    })
}
export function sayHello (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, helloworld.HelloRequest, {users: helloworld.User})
  logRequest('sayHello', arg.params)
  return grpc.call({
      client: GreeterPromiseClient,
      method: 'sayHello',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      logResponse('sayHello', JSON.parse(JSON.stringify(res)))
      if (arg.hasMutation) context.commit(types.GREETER_SAYHELLO, res)
      return res
    })
    .catch((err)=>{
      logError('sayHello', err)
      throw err
    })
}
`
    )
  })
  it('returns valid js code when simple proto', () => {
    const protoName = 'ping'
    const json = toJSON(proto2)
    const services = getServices(json)
    const messages = getMessages(json)
    const models = getModels(messages, protoName)
    const mutationTypes = getMutationTypes(services)
    const actions = getActions(services, protoName)
    const param = {
      mutationTypes,
      actions,
      models,
    }
    const code = generateCode([param], 'http://localhost:8080/', true)
    expect(_.isString(code)).toBeTruthy()
    expect(code).toBe(
`import GRPC from './grpc'
import { logRequest, logResponse, logError } from './debug'
import { createRequest } from './request'
import { convertResponse } from './response'
import ping from './ping_pb'
import { PingServicePromiseClient } from './ping_grpc_web_pb'

export const types = {
  PINGSERVICE_SENDPING: 'PINGSERVICE_SENDPING',
}

export const grpc = new GRPC('http://localhost:8080/')
export function sendPing (context, arg) {
  if (!arg) arg = {}
  const req = createRequest(arg.params || {}, ping.PingRequest, {})
  logRequest('sendPing', arg.params)
  return grpc.call({
      client: PingServicePromiseClient,
      method: 'sendPing',
      req,
      options: arg.options,
      params: arg.params,
    })
    .then((raw)=>{
      const res = convertResponse(raw.toObject())
      logResponse('sendPing', JSON.parse(JSON.stringify(res)))
      if (arg.hasMutation) context.commit(types.PINGSERVICE_SENDPING, res)
      return res
    })
    .catch((err)=>{
      logError('sendPing', err)
      throw err
    })
}
`
    )
  })
})

describe('generateDtsCode', ()=>{
  it('returns js code', () => {
    const json = toJSON(proto)
    const services = getServices(json)
    const messages = getMessages(json)
    const actions = getActions(services)
    expect(generateDtsCode([{ messages, actions }])).toBe(
`class GRPC {
  endpoint:string;
  defaultOptions:object;
  constructor(endpoint?:string);
  getDeadline(sec:number);
  call(arr:{ client:string, method:string, req:object, options:object });
  error( err:Error, info:{ method:string, req:object } );
  onError( err:Error, req:object, method:string );
}
export var grpc:GRPC;

interface ActionArgument<T> {
  params:T;
  hasMutation:boolean;
  options:object;
}

export var types:{
  GREETER_SAYHELLO: 'GREETER_SAYHELLO';
}

interface User {
  name?:string;
  age?:number;
  children?:string[];
}
interface HelloRequest {
  users?:User[];
}
interface HelloReply {
  users?:User[];
}
export function sayHello(arg:ActionArgument<HelloRequest>):Promise<HelloReply>;`)
  })
  it('returns multiple js code', () => {
    const json = toJSON(proto)
    const services = getServices(json)
    const messages = getMessages(json)
    const actions = getActions(services)
    expect(generateDtsCode([{ messages, actions }, { messages, actions }])).toBe(
`class GRPC {
  endpoint:string;
  defaultOptions:object;
  constructor(endpoint?:string);
  getDeadline(sec:number);
  call(arr:{ client:string, method:string, req:object, options:object });
  error( err:Error, info:{ method:string, req:object } );
  onError( err:Error, req:object, method:string );
}
export var grpc:GRPC;

interface ActionArgument<T> {
  params:T;
  hasMutation:boolean;
  options:object;
}

export var types:{
  GREETER_SAYHELLO: 'GREETER_SAYHELLO';
}

interface User {
  name?:string;
  age?:number;
  children?:string[];
}
interface HelloRequest {
  users?:User[];
}
interface HelloReply {
  users?:User[];
}
export function sayHello(arg:ActionArgument<HelloRequest>):Promise<HelloReply>;

interface User {
  name?:string;
  age?:number;
  children?:string[];
}
interface HelloRequest {
  users?:User[];
}
interface HelloReply {
  users?:User[];
}
export function sayHello(arg:ActionArgument<HelloRequest>):Promise<HelloReply>;`
    )
  })
  it('returns with imported code', () => {
    const proto = `
  syntax = "proto3";

  package helloworld;
  import "common.proto";

  service Greeter {
    rpc SayHello (HelloRequest) returns (HelloReply);
  }

  message HelloRequest {
    
  }

  message HelloReply {
    repeated User users = 1;
  }
`
    const json = toJSON(proto)
    const services = getServices(json)
    const messages = getMessages(json)
    const actions = getActions(services)
    expect(generateDtsCode([{ messages, actions }, { messages, actions }])).toBe(
`class GRPC {
  endpoint:string;
  defaultOptions:object;
  constructor(endpoint?:string);
  getDeadline(sec:number);
  call(arr:{ client:string, method:string, req:object, options:object });
  error( err:Error, info:{ method:string, req:object } );
  onError( err:Error, req:object, method:string );
}
export var grpc:GRPC;

interface ActionArgument<T> {
  params:T;
  hasMutation:boolean;
  options:object;
}

export var types:{
  GREETER_SAYHELLO: 'GREETER_SAYHELLO';
}

interface HelloReply {
  users?:User[];
}
export function sayHello():Promise<HelloReply>;

interface HelloReply {
  users?:User[];
}
export function sayHello():Promise<HelloReply>;`
    )
  })
})
